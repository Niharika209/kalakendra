/**
 * Search Sync Service
 * 
 * Handles synchronization between MongoDB collections and Atlas Search indexes.
 * Uses event-driven architecture to keep search indexes up-to-date in real-time.
 * 
 * Features:
 * - Real-time updates via Mongoose middleware
 * - Denormalized data for fast search performance
 * - Retry logic with exponential backoff
 * - Bulk re-indexing for data migrations
 */

import Artist from '../models/Artist.js';
import Workshop from '../models/Workshop.js';
import Booking from '../models/Booking.js';
import EventEmitter from 'events';

// Event bus for search index updates
export const searchSyncEmitter = new EventEmitter();

/**
 * Atlas Search Sync Operations
 * Note: Atlas Search auto-syncs from MongoDB, but we track changes for analytics
 * and handle complex denormalization (e.g., artist data in workshop searches)
 */

class SearchSyncService {
  constructor() {
    this.retryAttempts = 3;
    this.retryDelay = 1000; // ms
  }

  /**
   * Update search-optimized fields for an artist
   * Called by Mongoose post-save hooks
   */
  async syncArtist(artistId) {
    try {
      const artist = await Artist.findById(artistId);
      if (!artist) return;

      // searchText is auto-generated by pre-save hook
      // This method handles additional sync logic if needed
      
      console.log(`‚úÖ Artist synced to search: ${artist.name}`);
      searchSyncEmitter.emit('artist:synced', { artistId, name: artist.name });
      
      // If artist data changed, update denormalized data in workshops
      await this.syncArtistWorkshops(artistId);
      
      return { success: true, artistId };
    } catch (error) {
      console.error('‚ùå Artist sync failed:', error);
      searchSyncEmitter.emit('sync:error', { type: 'artist', artistId, error });
      throw error;
    }
  }

  /**
   * Sync all workshops for an artist when artist data changes
   * Updates denormalized artist info in workshop search
   */
  async syncArtistWorkshops(artistId) {
    try {
      const workshops = await Workshop.find({ artist: artistId });
      
      for (const workshop of workshops) {
        await workshop.save(); // Triggers pre-save hook to regenerate searchText
      }
      
      console.log(`‚úÖ Synced ${workshops.length} workshops for artist ${artistId}`);
      return workshops.length;
    } catch (error) {
      console.error('‚ùå Workshop sync failed:', error);
      throw error;
    }
  }

  /**
   * Update search-optimized fields for a workshop
   */
  async syncWorkshop(workshopId) {
    try {
      const workshop = await Workshop.findById(workshopId).populate('artist', 'name category rating');
      if (!workshop) return;

      // searchText and calculated fields updated by pre-save hook
      
      console.log(`‚úÖ Workshop synced to search: ${workshop.title}`);
      searchSyncEmitter.emit('workshop:synced', { workshopId, title: workshop.title });
      
      return { success: true, workshopId };
    } catch (error) {
      console.error('‚ùå Workshop sync failed:', error);
      searchSyncEmitter.emit('sync:error', { type: 'workshop', workshopId, error });
      throw error;
    }
  }

  /**
   * Update availability when a booking is created/cancelled
   * Critical for showing accurate seat availability in search results
   */
  async updateWorkshopAvailability(workshopId) {
    try {
      const workshop = await Workshop.findById(workshopId);
      if (!workshop) return;

      // seatsAvailable and isFullyBooked auto-calculated by pre-save hook
      await workshop.save();
      
      console.log(`‚úÖ Workshop availability updated: ${workshop.title}`);
      searchSyncEmitter.emit('availability:updated', { 
        workshopId, 
        seatsAvailable: workshop.seatsAvailable,
        isFullyBooked: workshop.isFullyBooked 
      });
      
      return { success: true, seatsAvailable: workshop.seatsAvailable };
    } catch (error) {
      console.error('‚ùå Availability update failed:', error);
      throw error;
    }
  }

  /**
   * Calculate and update nextAvailableDate for an artist
   * Run as background job after bookings change
   */
  async updateArtistAvailability(artistId) {
    try {
      const artist = await Artist.findById(artistId);
      if (!artist || !artist.availability) return;

      // Find the next available slot
      const now = new Date();
      let nextDate = null;

      const sortedAvailability = artist.availability
        .filter(slot => new Date(slot.date) >= now && slot.slots.length > 0)
        .sort((a, b) => new Date(a.date) - new Date(b.date));

      if (sortedAvailability.length > 0) {
        nextDate = sortedAvailability[0].date;
      }

      artist.availabilitySettings.nextAvailableDate = nextDate;
      artist.availabilitySettings.isAvailable = nextDate !== null;
      await artist.save();

      console.log(`‚úÖ Artist availability updated: ${artist.name}, next available: ${nextDate}`);
      
      return { success: true, nextAvailableDate: nextDate };
    } catch (error) {
      console.error('‚ùå Artist availability update failed:', error);
      throw error;
    }
  }

  /**
   * Handle document deletion
   * Atlas Search auto-removes deleted docs, but we emit events for cleanup
   */
  async handleDeletion(modelName, docId) {
    console.log(`üóëÔ∏è ${modelName} deleted from search: ${docId}`);
    searchSyncEmitter.emit('document:deleted', { modelName, docId });
  }

  /**
   * Bulk re-index all documents
   * Use for: migrations, index rebuilds, fixing data inconsistencies
   */
  async bulkReindexArtists(batchSize = 100) {
    try {
      const totalArtists = await Artist.countDocuments();
      let processed = 0;

      console.log(`üîÑ Starting bulk re-index of ${totalArtists} artists...`);

      while (processed < totalArtists) {
        const artists = await Artist.find()
          .skip(processed)
          .limit(batchSize)
          .lean();

        for (const artist of artists) {
          try {
            // Update searchText and availability
            await Artist.findByIdAndUpdate(artist._id, {
              $set: { updatedAt: new Date() } // Triggers pre-save hook
            });
          } catch (err) {
            console.error(`Failed to reindex artist ${artist._id}:`, err);
          }
        }

        processed += artists.length;
        console.log(`Progress: ${processed}/${totalArtists} artists reindexed`);
        
        // Prevent overwhelming the database
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      console.log(`‚úÖ Bulk reindex complete: ${totalArtists} artists`);
      return { success: true, totalProcessed: totalArtists };
    } catch (error) {
      console.error('‚ùå Bulk reindex failed:', error);
      throw error;
    }
  }

  async bulkReindexWorkshops(batchSize = 100) {
    try {
      const totalWorkshops = await Workshop.countDocuments();
      let processed = 0;

      console.log(`üîÑ Starting bulk re-index of ${totalWorkshops} workshops...`);

      while (processed < totalWorkshops) {
        const workshops = await Workshop.find()
          .skip(processed)
          .limit(batchSize)
          .lean();

        for (const workshop of workshops) {
          try {
            await Workshop.findByIdAndUpdate(workshop._id, {
              $set: { updatedAt: new Date() }
            });
          } catch (err) {
            console.error(`Failed to reindex workshop ${workshop._id}:`, err);
          }
        }

        processed += workshops.length;
        console.log(`Progress: ${processed}/${totalWorkshops} workshops reindexed`);
        
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      console.log(`‚úÖ Bulk reindex complete: ${totalWorkshops} workshops`);
      return { success: true, totalProcessed: totalWorkshops };
    } catch (error) {
      console.error('‚ùå Bulk reindex failed:', error);
      throw error;
    }
  }

  /**
   * Retry failed operations with exponential backoff
   */
  async retryOperation(operation, attempts = this.retryAttempts) {
    for (let i = 0; i < attempts; i++) {
      try {
        return await operation();
      } catch (error) {
        if (i === attempts - 1) throw error;
        
        const delay = this.retryDelay * Math.pow(2, i);
        console.log(`‚ö†Ô∏è Retry attempt ${i + 1}/${attempts} after ${delay}ms`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
}

export const searchSync = new SearchSyncService();

/**
 * Event listeners for monitoring
 */
searchSyncEmitter.on('artist:synced', ({ artistId, name }) => {
  // Optional: Log to analytics, update cache, etc.
  // console.log(`Analytics: Artist ${name} search index updated`);
});

searchSyncEmitter.on('workshop:synced', ({ workshopId, title }) => {
  // Optional: Clear related caches, notify subscribers
  // console.log(`Analytics: Workshop ${title} search index updated`);
});

searchSyncEmitter.on('sync:error', ({ type, error }) => {
  // Optional: Send to error tracking service (Sentry, etc.)
  console.error(`Sync error for ${type}:`, error.message);
});

export default searchSync;
